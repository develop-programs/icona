import fs from "fs";
import path from "path";
import { toPascalCase } from "./pascal";

/**
 * Generate TypeScript definitions for all available icons
 */
export function generateIconTypes(iconsPath: string, outputPath: string): void {
    const iconNames = scanIconNames(iconsPath);
    const typeDefinitions = createTypeDefinitions(iconNames);

    fs.writeFileSync(outputPath, typeDefinitions);
    console.log(`✅ Generated TypeScript definitions with ${iconNames.length} icon names`);
}

/**
 * Scan the icons directory and extract all icon names
 */
function scanIconNames(iconsPath: string): string[] {
    const iconNames: string[] = [];

    function walkDir(dir: string) {
        if (!fs.existsSync(dir)) return;

        fs.readdirSync(dir).forEach(file => {
            const fullPath = path.join(dir, file);
            const stat = fs.statSync(fullPath);

            if (stat.isDirectory()) {
                walkDir(fullPath);
            } else if (file.endsWith(".svg")) {
                const iconName = file.replace(".svg", "");
                iconNames.push(iconName);
            }
        });
    }

    walkDir(iconsPath);
    return iconNames.sort();
}

/**
 * Create TypeScript type definitions from icon names
 */
function createTypeDefinitions(iconNames: string[]): string {
    const componentNames = iconNames.map(name => toPascalCase(name));

    // Create union types for icon names
    const iconNameUnion = iconNames.map(name => `'${name}'`).join(' | ');
    const componentNameUnion = componentNames.map(name => `'${name}'`).join(' | ');

    // Create icon registry interface
    const iconRegistry = iconNames.map(name => {
        const componentName = toPascalCase(name);
        return `  '${name}': {\n    name: '${name}';\n    component: '${componentName}';\n    description?: string;\n    keywords?: string[];\n    tags?: string[];\n    category?: string;\n  }`;
    }).join(';\n');

    return `// Auto-generated TypeScript definitions for Icona icons
// Do not edit this file manually - it will be overwritten

/**
 * Union type of all available icon names
 */
export type IconName = ${iconNameUnion};

/**
 * Union type of all icon component names (PascalCase)
 */
export type IconComponentName = ${componentNameUnion};

/**
 * Icon registry interface for metadata and search
 */
export interface IconRegistry {
${iconRegistry};
}

/**
 * Icon search result
 */
export interface IconSearchResult {
  name: IconName;
  component: IconComponentName;
  description?: string;
  keywords?: string[];
  tags?: string[];
  category?: string;
  score: number;
}

/**
 * Icon search options
 */
export interface IconSearchOptions {
  /** Search query */
  query: string;
  /** Maximum number of results to return */
  limit?: number;
  /** Categories to search within */
  categories?: string[];
  /** Tags to filter by */
  tags?: string[];
  /** Minimum score threshold */
  minScore?: number;
}

/**
 * Icon component props interface
 */
export interface IconProps {
  /** Size of the icon (width and height) */
  size?: number | string;
  /** Color of the icon */
  color?: string;
  /** CSS class name */
  className?: string;
  /** Accessibility title */
  title?: string;
  /** Accessibility label */
  'aria-label'?: string;
  /** Additional CSS styles */
  style?: React.CSSProperties;
}

/**
 * Icon component type
 */
export type IconComponent = React.ForwardRefExoticComponent<
  IconProps & React.RefAttributes<SVGSVGElement>
>;

/**
 * Utility type to get all icon names starting with a prefix
 * Usage: IconsStartingWith<'che'> will give you all icon names starting with 'che'
 */
export type IconsStartingWith<T extends string> = Extract<IconName, \`\${T}\${string}\`>;

/**
 * Utility type to get all icon names containing a substring
 * Usage: IconsContaining<'arrow'> will give you all icon names containing 'arrow'
 */
export type IconsContaining<T extends string> = Extract<IconName, \`\${string}\${T}\${string}\`>;

declare module 'icona' {
  /**
   * Search for icons by query
   */
  export function searchIcons(options: IconSearchOptions): IconSearchResult[];
  
  /**
   * Get icon metadata by name
   */
  export function getIconMetadata(name: IconName): IconSearchResult | undefined;
  
  /**
   * Get all available icon names
   */
  export function getAllIconNames(): IconName[];
  
  /**
   * Get all available icon names in a category
   */
  export function getIconsByCategory(category: string): IconName[];
  
  /**
   * Get all available categories
   */
  export function getCategories(): string[];
}
`;
}

/**
 * Generate icon registry data for runtime use
 */
export function generateIconRegistry(iconsPath: string, outputPath: string): void {
    const iconData = scanIconsWithMetadata(iconsPath);
    const registryCode = createRegistryCode(iconData);

    fs.writeFileSync(outputPath, registryCode);
    console.log(`✅ Generated icon registry with ${iconData.length} icons`);
}

interface IconData {
    name: string;
    component: string;
    category?: string;
    path: string;
}

function scanIconsWithMetadata(iconsPath: string): IconData[] {
    const iconData: IconData[] = [];

    function walkDir(dir: string, category?: string) {
        if (!fs.existsSync(dir)) return;

        fs.readdirSync(dir).forEach(file => {
            const fullPath = path.join(dir, file);
            const stat = fs.statSync(fullPath);

            if (stat.isDirectory()) {
                const subCategory = category ? `${category}/${file}` : file;
                walkDir(fullPath, subCategory);
            } else if (file.endsWith(".svg")) {
                const iconName = file.replace(".svg", "");
                const componentName = toPascalCase(iconName);

                iconData.push({
                    name: iconName,
                    component: componentName,
                    ...(category && { category }),
                    path: fullPath
                });
            }
        });
    }

    walkDir(iconsPath);
    return iconData.sort((a, b) => a.name.localeCompare(b.name));
}

function createRegistryCode(iconData: IconData[]): string {
    const imports = iconData.map(icon => {
        const importPath = icon.category
            ? `./${icon.category}/${icon.name}`
            : `./${icon.name}`;
        return `import { default as ${icon.component} } from '${importPath}';`;
    }).join('\n');

    const registryEntries = iconData.map(icon => {
        return `  '${icon.name}': {
    name: '${icon.name}',
    component: ${icon.component},
    category: '${icon.category || ''}',
    description: getIconDescription('${icon.name}', '${icon.category || ''}'),
    keywords: getIconKeywords('${icon.name}', '${icon.category || ''}'),
    tags: getIconTags('${icon.name}', '${icon.category || ''}')
  }`;
    }).join(',\n');

    return `// Auto-generated icon registry
// Do not edit this file manually

import { generateIconMetadata } from '../utils/metadata';
import type { IconRegistry, IconName, IconComponentName } from '../types/icons';

${imports}

// Helper functions to generate metadata
function getIconDescription(name: string, category: string): string {
  return generateIconMetadata(name, category).description || '';
}

function getIconKeywords(name: string, category: string): string[] {
  return generateIconMetadata(name, category).keywords || [];
}

function getIconTags(name: string, category: string): string[] {
  return generateIconMetadata(name, category).tags || [];
}

/**
 * Complete icon registry with all available icons and their metadata
 */
export const iconRegistry: IconRegistry = {
${registryEntries}
} as const;

/**
 * Array of all available icon names
 */
export const allIconNames: IconName[] = [
  ${iconData.map(icon => `'${icon.name}'`).join(',\n  ')}
] as const;

/**
 * Array of all icon component names
 */
export const allComponentNames: IconComponentName[] = [
  ${iconData.map(icon => `'${icon.component}'`).join(',\n  ')}
] as const;
`;
}